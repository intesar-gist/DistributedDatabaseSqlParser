/* Auther: Intesar Haider */
/* DDB parser.jj*/
/* Generating all the parser code */

options
{
    STATIC = false ;
}
PARSER_BEGIN (SqlParser)
   package sqlParser;
   import java.util.ArrayList;
   import java.util.HashMap;
   import sqlParser.utilities.*;
   class SqlParser {
         Boolean initParser() throws ParseException, TokenMgrError
   { return(init()) ; }
   }
PARSER_END (SqlParser)


/* white-space, comments */
SKIP: {
      " " | "\t" | "\n" | "\r" | "\f"
}
SKIP: {
    <COMMENT_LINE: "--" (~["\n","\r"])* ("\n"|"\r"|"\r\n") >
}
SKIP:{
    <COMMENT_BLOCK: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

/* separator and operator literals (prefix with O_) */
TOKEN: {
      <O_ASTERISK: "*"> | <O_CLOSEPAREN: ")"> | <O_OPENPAREN: "(">
    | <O_COMMA: ",">   | <O_TERMINATOR: ";">  | <O_DOT: ".">
    | <O_PERCENT: "%"> | <O_EQUAL: "="> | <O_GREATER: ">">
    | <O_GREATEREQUAL: ">="> | <O_LESS: "<"> | <O_LESSEQUAL: "<=">
    | <O_MINUS: "-"> | <O_NOTEQUAL2: "<>"> | <O_NOTEQUAL: "!=">
}

/* numeric literals */
TOKEN : {
     <FLOAT: <INTEGER> ( "." <INTEGER> ) | "." <INTEGER> >
    | <INTEGER: ( <DIGIT> )+ >
    | <#DIGIT: ["0" - "9"] >
}

/* reserved words and keywords literals */
TOKEN [IGNORE_CASE]: {

	//K_ prefixed tokens are reserved words that's shouldn't be used in column names
      <K_CREATE: "CREATE">
    | <K_DROP: "DROP">
    | <K_TABLE: "TABLE">
    | <K_INSERT: "INSERT">
    | <K_INTO: "INTO">
    | <K_DELETE: "DELETE">
    | <K_FROM: "FROM">

    | <R_AND: "AND">
    | <R_ASC: "ASC">
    | <R_BY: "BY">
    | <R_CONNECT: "CONNECT">
    | <R_DESC: "DESC">
    | <R_DISTINCT: "DISTINCT">
    | <R_GROUP: "GROUP">
    | <R_HAVING: "HAVING">
    | <R_IN: "IN">
    | <R_IS: "IS">
    | <R_LIKE: "LIKE">
    | <R_NOT: "NOT">
    | <R_NULL: "NULL">
    | <R_OR: "OR">
    | <R_ORDER: "ORDER">
    | <R_SELECT: "SELECT">
    | <R_UNIQUE: "UNIQUE">
    | <R_UPDATE: "UPDATE">
    | <R_VALUES: "VALUES">
    | <R_WHERE: "WHERE">
    | <R_CONSTRAINT: "CONSTRAINT">
    | <R_CREATE :("CREATE TABLE")>
    | <R_DROP :("DROP TABLE")>
    | <R_INSERT :("INSERT INTO")>
    | <R_DELETE :("DELETE FROM")>
    | <R_PRIMARY: ("PRIMARY KEY")>
    | <R_FOREIGN: ("FOREIGN KEY")>
    | <R_INTEGER: "INTEGER">
    | <R_VARCHAR: "VARCHAR">
    | <R_HORIZONTAL: "HORIZONTAL">
    | <R_SET: "SET">
    | <R_SUM: "SUM">
    | <R_COUNT: "COUNT">
    | <R_CHECK: "CHECK">
    | <R_BETWEEN: "BETWEEN">
    | <R_REFERENCES: "REFERENCES">
}

/* query specific tokens */
TOKEN [IGNORE_CASE]: {
      <Q_ATTRIBUTE: (<S_IDENTIFIER><O_DOT><S_IDENTIFIER>)>
    | <Q_COUNT: (<R_COUNT><O_OPENPAREN><O_ASTERISK><O_CLOSEPAREN>)>
    | <Q_SUM: (<R_SUM><O_OPENPAREN><Q_ATTRIBUTE><O_CLOSEPAREN>)>
}

/* identifier literals */
TOKEN: {
      <S_IDENTIFIER: (<LETTER>)+ (<DIGIT> | <LETTER> | <SPECIAL_CHARS>)* >
    | <#LETTER: ["a"-"z", "A"-"Z"] >
    | <#SPECIAL_CHARS: "_" >
    | <QUOTED_STRING: <EMPTY_STRING> | "'" (~["'"])+ "'" >
    | <#EMPTY_STRING: ("'" "'") >
}

//Grammer Production Rules

Boolean init():
{
    ArrayList<QueryType> queries = new ArrayList<QueryType>();
    QueryType queryType;
}
{
	(
		(queryType = ProcessDDLQuery() | queryType = ProcessDMLQuery() | queryType = ProcessQLQuery())
		{
  	  		queries.add(queryType);
		}
	)* 
    
    <EOF>

    {return true;}
}

/********************************/
/********* QL queries **********/
/********************************/
QLQuery ProcessQLQuery():
{
    QLQuery qlQuery;
    Token queryType;
}
{
	queryType = <R_SELECT>
	(qlQuery = countAllTable() |LOOKAHEAD(3) qlQuery = aggregateFuncWithGroupby() | qlQuery = selectWithJoins())
    {
	    qlQuery.setQueryType(queryType.kind);
    	return qlQuery;
    }
}

/* select with and withuot joins */
QLQuery selectWithJoins():
{
    Token T;
    QLQuery qlQuery = new QLQuery();
}
{
	   (getListOfAttributes() | <O_ASTERISK>)
	   <K_FROM> 
	   (LOOKAHEAD(2)<S_IDENTIFIER><O_COMMA><S_IDENTIFIER> | LOOKAHEAD(2)<S_IDENTIFIER>)
	   [whereWithJoin()]
       <O_TERMINATOR>
    
       {return qlQuery;}
}

void whereWithJoin(): {} {
	<R_WHERE> (LOOKAHEAD(4) singleJoinCondition() | LOOKAHEAD(3) nonJoinCondition() )
}

void singleJoinCondition(): {} {
	<O_OPENPAREN><Q_ATTRIBUTE> ComparisonOperators() <Q_ATTRIBUTE><O_CLOSEPAREN> [<R_AND> nonJoinCondition()]
}

void nonJoinCondition(): {} {
  <O_OPENPAREN>(<Q_ATTRIBUTE> ComparisonOperators() (<QUOTED_STRING> | <FLOAT> | <INTEGER>))<O_CLOSEPAREN> [((<R_AND> | <R_OR>) nonJoinCondition())]
}

/* COUNT TABLE */
QLQuery countAllTable():
{
    Token T;
    QLQuery qlQuery;
}
{
	   <Q_COUNT>
	   <K_FROM> 
	   T = <S_IDENTIFIER>
	   {    
	      qlQuery = new QLQuery();
	      qlQuery.setTableName(T.image);
	   }
       <O_TERMINATOR>
    
       {return qlQuery;}
}

/* AGGREGATE FUNCTION WITH GROUP BY */
QLQuery aggregateFuncWithGroupby():
{
    Token T;
    QLQuery qlQuery;
}
{
	   <Q_ATTRIBUTE> <O_COMMA> getAggregateFunction() 
	   <K_FROM> 
	   T = <S_IDENTIFIER>
	   <R_GROUP> <R_BY> <Q_ATTRIBUTE>
	   {    
	      qlQuery = new QLQuery();
	      qlQuery.setTableName(T.image);
	   }
       <O_TERMINATOR>
    
       {return qlQuery;}
}

void getListOfAttributes():
{
}
{
	(<Q_ATTRIBUTE>)  [LOOKAHEAD(2) <O_COMMA> getListOfAttributes()]
}

void getAggregateFunction():
{
}
{
	<Q_COUNT> | <Q_SUM>
}


/********************************/
/********* DML queries **********/
/********************************/
DMLQuery ProcessDMLQuery():
{
    DMLQuery dmlQuery;
}
{
	(dmlQuery = insert() | dmlQuery = deleteTuple() | dmlQuery = updateTuple())
    {return dmlQuery;}
}

/* UPDATE TUPLE */
DMLQuery updateTuple():
{
    Token T;
    Token queryType;
    DMLQuery dmlQuery;
}
{
	   queryType = <R_UPDATE>
	   T =<S_IDENTIFIER>
	   <R_SET> ColumnSetter()
	   [<R_WHERE> ColumnComparison()]
	   {    
	      dmlQuery = new DMLQuery();
	      dmlQuery.setTableName(T.image);
	      dmlQuery.setQueryType(queryType.kind);
	   }
       <O_TERMINATOR>
    
       {return dmlQuery;}
}

void ColumnSetter():
{
}
{
	<S_IDENTIFIER> <O_EQUAL> (<QUOTED_STRING> | <FLOAT> | <INTEGER> | <R_NULL>) [(<O_COMMA>) ColumnSetter()]
}

/* INSERT TABLE */
DMLQuery insert():
{
    Token T;
    Token queryType;
    DMLQuery dmlQuery;
}
{
	   queryType = <R_INSERT>
	   T =<S_IDENTIFIER>
	   <R_VALUES> 
		   <O_OPENPAREN> 
		   		InsertValueExpressions()
		   <O_CLOSEPAREN>
	   {    
	      dmlQuery = new DMLQuery();
	      dmlQuery.setTableName(T.image);
	      dmlQuery.setQueryType(queryType.kind);
	   }
       <O_TERMINATOR>
    
       {return dmlQuery;}
}

void InsertValueExpressions():
{
}
{
  (<QUOTED_STRING> | <FLOAT> | <INTEGER> | <R_NULL>) [(<O_COMMA>) InsertValueExpressions()]
}

/* DELETE TUPLE */
DMLQuery deleteTuple():
{
    Token T;
    Token queryType;
    DMLQuery dmlQuery;
}
{
	   queryType = <R_DELETE>
	   T =<S_IDENTIFIER>
	   [<R_WHERE> ColumnComparison()]
	   {    
	      dmlQuery = new DMLQuery();
	      dmlQuery.setTableName(T.image);
	      dmlQuery.setQueryType(queryType.kind);
	   }
       <O_TERMINATOR>
    
       {return dmlQuery;}
}

void ColumnComparison():
{
}
{
  (<S_IDENTIFIER> ComparisonOperators() (<QUOTED_STRING> | <FLOAT> | <INTEGER>)) [((<R_AND> | <R_OR>) ColumnComparison())]
}

void ComparisonOperators():
{
}
{
  (<O_EQUAL> | <O_GREATER> | <O_GREATEREQUAL> | <O_LESS> | <O_LESSEQUAL> | <O_NOTEQUAL2> | <O_NOTEQUAL>) 
}

/********************************/
/********* DDL queries **********/
/********************************/

DDLQuery ProcessDDLQuery():
{
    DDLQuery ddlQuery;
}
{
	(ddlQuery = create() | ddlQuery = drop())
    {return ddlQuery;}
}

/* DROP TABLE */
DDLQuery drop():
{
    Token T;
    Token queryType;
    DDLQuery ddlQuery;
}
{
	   queryType = <R_DROP>
	   T =<S_IDENTIFIER>
	   {    
	      ddlQuery = new DDLQuery();
	      ddlQuery.setTableName(T.image);
	      ddlQuery.setQueryType(queryType.kind);
	   }
       <O_TERMINATOR>
    
       {return ddlQuery;}
}

/* CREATE TABLE */
DDLQuery create():
{
    Token T;
    Token queryType;
    DDLQuery ddlQuery;
    HashMap<String,String> attributes;
}
{
       queryType = <R_CREATE>
       T =<S_IDENTIFIER>
       {    
          ddlQuery = new DDLQuery ();
          ddlQuery.setTableName(T.image);
          ddlQuery.setQueryType(queryType.kind);
       }
      <O_OPENPAREN>
      attributes = ColumnsAndConstraints()
      <O_CLOSEPAREN>
      [processHorizontal()]
      <O_TERMINATOR>

     {
     	ddlQuery.setAttributes(attributes);
     	return ddlQuery;
     }
}

void processHorizontal():
{
}
{
  <R_HORIZONTAL> (<O_OPENPAREN><S_IDENTIFIER><O_OPENPAREN>PartioningLimits()<O_CLOSEPAREN><O_CLOSEPAREN>)
}

void PartioningLimits():
{
}
{
  (<INTEGER>)+ [<O_COMMA> <INTEGER>]
}

HashMap ColumnsAndConstraints():
{
   HashMap<String,String> var = new HashMap<String, String>();
}
{
  (
  		var = Columns()
  )+ 
  (
    	<O_COMMA> Constraints()
  )*
  {return var;}
}

HashMap Columns():
{
   Token TName;
   Token TType;
   HashMap<String,String> var = new HashMap<String, String>();
}
{
    TName = <S_IDENTIFIER> //name of the column
    TType = ColType()
    [LOOKAHEAD(2) <O_COMMA> Columns()]
    {var.put(TName.image,TType.image);}

  {return var;}
}

Token ColType():
{
   Token TDType;
}
{
    (TDType = <R_INTEGER> | TDType = <R_VARCHAR>)
    [<O_OPENPAREN><INTEGER><O_CLOSEPAREN>]
    {return TDType;}
}

void Constraints(): {} {
    <R_CONSTRAINT>
    ConstraintType()
    [LOOKAHEAD(2) <O_COMMA> Constraints()]

}

void ConstraintType(): {} {
  <S_IDENTIFIER> (CustomCheckConstraitns() | PrimaryOrUnique() | ForeignKey())
}

void ForeignKey(): {} {
    <R_FOREIGN> (<O_OPENPAREN><S_IDENTIFIER><O_CLOSEPAREN>) 
    <R_REFERENCES> <S_IDENTIFIER>(<O_OPENPAREN><S_IDENTIFIER><O_CLOSEPAREN>)
    
}

void PrimaryOrUnique(): {} {
    (<R_PRIMARY> | <R_UNIQUE>)
    (<O_OPENPAREN><S_IDENTIFIER><O_CLOSEPAREN>)
}

void CustomCheckConstraitns(): {} {
	<R_CHECK> 
	<O_OPENPAREN>
		( 
			   LOOKAHEAD(2) (<S_IDENTIFIER> (<R_IS> <R_NOT> <R_NULL>))
			| LOOKAHEAD(2) (<S_IDENTIFIER> ComparisonOperators() (<S_IDENTIFIER> | <QUOTED_STRING> | <FLOAT> | <INTEGER>)) 
			| LOOKAHEAD(2) (<S_IDENTIFIER> <R_BETWEEN> <INTEGER> <R_AND> <INTEGER>)
			| LOOKAHEAD(2) (<S_IDENTIFIER> <R_IN> <O_OPENPAREN> SingleQuoteStrings() <O_CLOSEPAREN>)
		)
	<O_CLOSEPAREN>
}

void SingleQuoteStrings(): {} {
	<QUOTED_STRING> [<O_COMMA> SingleQuoteStrings()]
}